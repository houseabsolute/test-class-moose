
=head1 Getting Started

XXX: Why choose test classes. Why choose Test::Class::Moose (isn't it self-evident?)

=head2 A Test Class

The first and most crucial part of using Test::Class::Moose is a class that runs some tests. Test::Class::Moose loads a few modules for you automatically, so the boilerplate is, at minimum:

    package testlib::My::Test::Class;
    use Test::Class::Moose;

Test::Class::Moose loads strict, warnings, Moose, and Test::Most (which includes Test::More, Test::Deep, Test::Exception, and Test::Differences).

I put my test classes in the t/testlib directory, to keep the separated from my other classes that help testing (t/lib) and my other test scripts. This is just a convention; the directory can be anything you want it to be, but it is a good idea to keep your test classes separate from your other test-related modules.

Now, we need a subroutine that runs our test. Test::Class::Moose test methods start with "test_". Any method that starts with "test_" will be run as a test.

    sub test_construction {
        my ( $test, $report ) = @_;
        use My::Module;
        my $obj = My::Module->new;
        isa_ok $obj, 'My::Module';
    }

Every "test_" sub is run as a subtest, and no plan is required. We can have as many "test_" subs as we want.

=head2 A Test Runner

Now that we have a test class, we need a way for prove to load and run them. Test::Class::Moose can load our test modules from a given directory, and it has a runtests() method that will run any test modules that have already been loaded.

    # t/testlib.t
    use File::Spec::Functions qw( catdir );
    use Test::Class::Moose qw( catdir( $Bin, testlib ) );
    Test::Class::Moose->runtests;

This test script will load all of the modules inside t/testlib/ and then run them. All your test modules get run by this one script, but since they're run as subtests, you will get a report on how many test classes failed.

We can run our test script using prove. I'll turn on verbose output (-v) to show you what the TAP output looks like

    prove -v t/testlib.t
    # XXX Show TAP output

=head1 Event Hooks

There are various points in the test script where we might want to perform some actions: Reset a test database, create a temp file, or otherwise set up prerequisites for a test. Test::Class::Moose provides some hooks that allow us to perform actions at these points.

=head2 test_startup / test_finished

test_startup happens as the very first thing in our test class, and is run only once per test class. This allows us to set up some global things, like a database that will be used throughout the entire test.

test_finished happens once as the very last thing in our test class, and is run only once per test class. This allows us to clean up things from test_startup, and also test to verify that anything from test_startup looks exactly as it should before we clean it up.

=head2 test_setup / test_teardown

test_setup happens before every test. For canonical unit testing, this is where you can create the things you need for each test, such as a log file.

test_teardown happens after every test, and is where you can clean up the things created in test_setup.

=head1 Test Class Composition

The most important reason to choose a class test over a procedural test (using only Test::More) is class composition. 

=head2 Inheritance

Since we're using Moose, inheritance is as easy as:

    package testlib::My::Test::Class;
    use Test::Moose::Class;
    extends 'My::Test::Base';

Test::Class::Moose even provides a shortcut:

    package testlib::My::Text::Class;
    use Test::Moose::Class => 'My::Test::Base';

Since My::Test::Base will not be testing anything itself, we do not put it in t/testlib, instead we put it in lib or t/lib (depending on if we want it to be part of the public set of modules or not). This will make sure our test runner does not try to run our base class that doesn't test anything concrete.

=head2 Roles

If your distribution uses roles, so should your tests. Like inheritance, roles are added in the regular Moose way:

    package testlib::My::Test::Class;
    use Test::Moose::Class;
    with 'My::Test::Role';

=head2 Organizing Your Tests

Test code should be held to the same standard as the rest of the code in your distribution:

=over 4

=item Don't Repeat Yourself

Copy/paste code isn't okay in your module code, and it should not be okay in your test code either! Refactor your tests to use roles or inheritance.

=back

=head1 Advanced Features

=head2 plan

If you need to prepare a plan for your tests, you can do so using the plan() method:

    sub test_constructor {
        my ( $test, $report ) = @_;
        $test->plan( 1 ); # 1 test in this sub
        isa_ok My::Module->new, 'My::Module';
    }

Using the plan() method, we can know exactly how many tests did not run if the test method ends prematurely. Without it, we would only get the message "No plan was seen", we would not know which tests were not run.

=head2 skip / todo

XXX: TODO ;)

=head2 Run Specific Test Classes

One of the problems with having only one test script to run all the test classes is when we're working directly with one test class we still have to run all the other test classes.

To fix this problem, Test::Moose::Class allows us to specify which specific classes we want to run in its constructor:

    # t/testlib.t
    use FindBin qw( $Bin );
    use Test::Class::Moose => $Bin;
    Test::Class::Moose->new(
        classes => [ 'testlib::My::Test::Class' ],
    )->runtests;

Now, we only run testlib::My::Test::Class instead of all the tests found in testlib::.

This isn't very elegant though, since we have to edit t/testlib.t every time we want to run a new test. So, Test::Class::Moose can also accept which test classes to run via @ARGV:

    # t/testlib.t
    use FindBin qw( $Bin );
    use Test::Class::Moose => $Bin;
    Test::Class::Moose->new(
        classes => \@ARGV,
    )->runtests;

If @ARGV is empty, Test::Class::Moose will run all classes. To give arguments while running C<prove>, we use the arisdottle C<::>:

    prove -lb t/testlib.t :: My::Test::Class

Now we can choose which test class we want to run right on the command line.

=head2 Test Tags

Tags are a way of organizing your test methods into groups. Later you can choose to only execute the test methods from one or more tags.

=head1 Boilerplate

Here is the bare minimum you need to get started using Test::Class::Moose

=head2 Test Class

    # t/testlib/My/Class.pm
    package testlib::My::Class;
    use Test::Class::Moose;

    sub test_something {
        pass "I tested something!";
    }

    1;

=head2 Test Runner

    # t/testlib.t
    use FindBin qw( $Bin );
    use Test::Class::Moose => $Bin;
    Test::Class::Moose->new(
        classes => \@ARGV,
    )->runtests;
